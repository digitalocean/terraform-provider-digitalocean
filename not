
// remove go.mod replace
// check if vendor files are required ?
// updated docs

//done
// create a new file for listall
// create a new go file for flatten logic genai.go

//resource_agent -- comments

//
///
//
//
//
//
//
//	// fmt.Print(agent.KnowledgeBases)
// if agent.KnowledgeBases != nil {
// 	if err := d.Set("knowledge_bases", flattenKnowledgeBases(agent.KnowledgeBases)); err != nil {
// 		return diag.FromErr(err)
// 	}
// }
// modelSlice := []*godo.Model{agent.Model}
// 	if err := d.Set("model", flattenModel(modelSlice)); err != nil {
// 		return diag.FromErr(err)
// 	}
// }
//
//
//
//
//
//

// func flattenKnowledgeBases(kbs []*godo.KnowledgeBase) []interface{} {
// 	if kbs == nil {
// 		return nil
// 	}
// 	kb := kbs[0] // Assuming you want to flatten only the first KnowledgeBase for simplicity
// 	// result := make([]interface{}, 0, len(kbs))
// 	// for _, kb := range kbs {
// 	m := map[string]interface{}{
// 		// "added_to_agent_at":    kb.AddedToAgentAt.UTC().String(),
// 		// "created_at":           kb.CreatedAt.UTC().String(),
// 		"database_id":          kb.DatabaseId,
// 		"embedding_model_uuid": kb.EmbeddingModelUuid,
// 		"is_public":            kb.IsPublic,
// 		"name":                 kb.Name,
// 		"project_id":           kb.ProjectId,
// 		"region":               kb.Region,
// 		"user_id":              kb.UserId,
// 		"uuid":                 kb.Uuid,
// 		// "tags":                 kb.Tags,
// 	}

// 	// Flatten tags (assumed to be a []string)
// 	// if kb.Tags != nil {
// 	// 	tags := make([]interface{}, len(kb.Tags))
// 	// 	for i, tag := range kb.Tags {
// 	// 		tags[i] = tag
// 	// 	}
// 	// 	m["tags"] = tags
// 	// }

// 	// Flatten last indexing job as a nested block if present.
// 	// if kb.LastIndexingJob != nil {
// 	// 	m["last_indexing_job"] = flattenLastIndexingJob(kb.LastIndexingJob)
// 	// }

// 	// result = append(result, m)
// 	// }
// 	return []interface{}{m}
// }

// func flattenModel(model *[]godo.Model) []interface{} {
// 	if model == nil {
// 		return nil
// 	}

// 	m := map[string]interface{}{
// 		"created_at":        model.CreatedAt.UTC().String(),
// 		"inference_name":    model.InferenceName,
// 		"inference_version": model.InferenceVersion,
// 		"is_foundational":   model.IsFoundational,
// 		"name":              model.Name,
// 		"parent_uuid":       model.ParentUuid,
// 		"provider":          model.Provider,
// 		"updated_at":        model.UpdatedAt.UTC().String(),
// 		"upload_complete":   model.UploadComplete,
// 		"url":               model.Url,
// 		"usecases":          model.Usecases,
// 		// "versions":          model.Versions, - double nesting
// 	}

// 	if model.Version != nil {
// 		versionMap := map[string]interface{}{
// 			"major": model.Version.Major,
// 			"minor": model.Version.Minor,
// 			"patch": model.Version.Patch,
// 		}
// 		m["versions"] = []interface{}{versionMap}
// 	}

// 	if model.Agreement != nil {
// 		agreementMap := map[string]interface{}{
// 			"description": model.Agreement.Description,
// 			"name":        model.Agreement.Name,
// 			"url":         model.Agreement.Url,
// 			"uuid":        model.Agreement.Uuid,
// 		}
// 		m["agreement"] = []interface{}{agreementMap}
// 	}

// 	return []interface{}{m}
// }

// agentRequest.Uuid = d.Get("id").(string)
// if d.HasChange("uuid") {
// 	agentRequest.Uuid = d.Get("uuid").(string) // Assuming it's a string
// }

// agentRequest := &godo.AgentUpdateRequest{
// 	AnthropicKeyUuid: d.Get("anthropic_key_uuid").(string),
// 	Description:      d.Get("description").(string),
// 	Name:             d.Get("name").(string),
// 	Instruction:      d.Get("instruction").(string),
// 	ModelUuid:        d.Get("model_uuid").(string),
// 	Region:           d.Get("region").(string),
// 	ProjectId:        d.Get("project_id").(string),
// 	K:                d.Get("k").(int),
// 	MaxTokens:        d.Get("max_tokens").(int),
// 	OpenAiKeyUuid:    d.Get("open_ai_key_uuid").(string),
// }

//resource comments

// // DataSourceDigitalOceanAgentList defines the data source for listing agents.
// func DataSourceDigitalOceanAgentList() *schema.Resource {
// 	return &schema.Resource{
// 		ReadContext: dataSourceDigitalOceanAgentListRead,
// 		Schema: map[string]*schema.Schema{
// 			"agents": {
// 				Type:        schema.TypeList,
// 				Computed:    true,
// 				Description: "List of agents",
// 				Elem: &schema.Resource{
// 					Schema: AgentSchemaRead().Schema,
// 				},
// 			},
// 		},
// 	}
// }

// func dataSourceDigitalOceanAgentListRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
// 	client := meta.(*config.CombinedConfig).GodoClient()

// 	agents, _, err := client.GenAI.ListAgents(ctx, nil)
// 	if err != nil {
// 		return diag.FromErr(err)
// 	}

// 	var results []map[string]interface{}
// 	for _, agent := range agents {
// 		result := map[string]interface{}{
// 			"anthropic_api_key": flattenAnthropicApiKey(agent.AnthropicApiKey),
// 			"api_key_infos":     flattenApiKeyInfos(agent.ApiKeyInfos),
// 			"api_keys":          flattenApiKeys(agent.ApiKeys),
// 			"chatbot":           flattenChatbot(agent.ChatBot),
// 			//chatbotidentifiers
// 			"created_at":      agent.CreatedAt.UTC().String(),
// 			"child_agents":    flattenChildAgents(agent.ChildAgents),
// 			"deployment":      flattenDeployment(agent.Deployment),
// 			"description":     agent.Description,
// 			"updated_at":      agent.UpdatedAt.UTC().String(),
// 			"functions":       flattenFunctions(agent.Functions),
// 			"agent_guardrail": flattenAgentGuardrail(agent.Guardrails),
// 			"if_case":         agent.IfCase,
// 			"instruction":     agent.Instruction,
// 			"k":               agent.K,
// 			"knowledge_bases": flattenKnowledgeBases(agent.KnowledgeBases),
// 			"max_tokens":      agent.MaxTokens,
// 			"name":            agent.Name,
// 			"open_ai_api_key": flattenOpenAiApiKey(agent.OpenAiApiKey),
// 			//ParentAgents
// 			"project_id":       agent.ProjectId,
// 			"region":           agent.Region,
// 			"retrieval_method": agent.RetrievalMethod,
// 			"route_created_at": agent.RouteCreatedAt.UTC().String(),
// 			"route_created_by": agent.RouteCreatedBy,
// 			"route_uuid":       agent.RouteUuid,
// 			"route_name":       agent.RouteName,
// 			"tags":             agent.Tags,
// 			"template":         flattenTemplate(agent.Template),
// 			"temperature":      agent.Temperature,
// 			"top_p":            agent.TopP,
// 			"url":              agent.Url,
// 			"user_id":          agent.UserId,
// 			"agent_id":         agent.Uuid,
// 		}
// 		results = append(results, result)
// 	}

// 	if err := d.Set("agents", results); err != nil {
// 		return diag.FromErr(err)
// 	}

// 	d.SetId("agent-list")
// 	return nil
// }

